#include "TraceXploit.h"

struct rNode *rHead = (struct rNode*) NULL;
struct rNode *rEnd  = (struct rNode*) NULL;

extern char PCAPIPSRC[20];
extern char PCAPIPDST[20];
extern unsigned int PORTDST;
extern unsigned int nNodeCount;

bool fnReplay (const unsigned char* chPkt, unsigned int nPktSize, char* pOriginTargetIP, char* pReplayTargetIP) 
{
        int i;
        struct rNode* pCurr = (struct rNode*) NULL;
        
        try {
                //check whether this pkt is c-s or s-c (replay only c-s pkts in .pcap) -> pOriginTargetIP should be PCAPIPDST
                if (strcmp(pOriginTargetIP, (const char*)PCAPIPDST) != 0) return false;

                //check whether state of this pkt has already been created in linked list
                if (!fnCheckState()) {

                        //establish connection for 1st time to this dst port -> store state in node
                        WSADATA wsaData;
                        SOCKET connectSocket;
                        struct sockaddr_in serverAddr;

                        WSAStartup(MAKEWORD(2,2), &wsaData);            //don't catch error as might have been initialized previously
                        connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                        if(connectSocket == INVALID_SOCKET) throw "fnReplay: create TCP socket() fail";

                        serverAddr.sin_family = AF_INET;
                        serverAddr.sin_addr.s_addr = inet_addr(pReplayTargetIP ); 
                        serverAddr.sin_port = htons(PORTDST);           
                        memset(&(serverAddr.sin_zero), '\0', 8);        
        
                        if (connect(connectSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
                                throw "fnReplay: connect() to server fail";
                        }
                        else {
                                if (!rAddNode(connectSocket, serverAddr, pReplayTargetIP))      throw "fnReplay: replayAddNode() new port connection fail";
                        }
                }

                //replay this pkt by finding relevant node for correct socket
                pCurr = rHead;
                unsigned char* pSendPkt = (unsigned char*) calloc (nPktSize, sizeof(char));;

                while (pCurr != NULL) {
                        if (pCurr->nPortDst == PORTDST) {
                                //TODO: parse for fields such as cookies, dst ip string, and replace
                                //      rem to change pSendPkt size if needed
                                //now, only parse for dst ip string, and replace with targetIP
                                fnChangePktFields (chPkt, pSendPkt, nPktSize, pReplayTargetIP);

                                if (send(pCurr->connectSocket, (char*)pSendPkt, (int)_msize(pSendPkt), 0)==SOCKET_ERROR) throw "fnReplay: send() fail";
                                break;
                        }
                        pCurr = pCurr->next;
                }
                if (pCurr == NULL) throw "fnReplay: Socket not found in linked list to send pkt";


                //recv target response
                HANDLE hThread[5] = {'\0'};
                DWORD dwThreadID[5] = {'\0'};
                pRecvPktParam pParam[5] = {'\0'};

                pCurr = rHead;
                for (i=0; pCurr != NULL; i++) {
                        pParam[i] = (pRecvPktParam) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(recvPktParam));
                        pParam[i]->pNode = pCurr;
                        hThread[i] = CreateThread( NULL, 0,     (LPTHREAD_START_ROUTINE)fnRecvPkt, pParam[i], 0, &dwThreadID[i]);

                        pCurr = pCurr->next;
                }

                WaitForMultipleObjects(i, hThread, false, 5000);


                //TODO: prog does not handle situations where 1 port finished receiving while another still receiving
                // Close thread handles and free memory
            for(i=0; i<5; i++)
                {
                        if (hThread[i]!=NULL)   CloseHandle(hThread[i]);
                        if(pParam[i] != NULL)   {
                                HeapFree(GetProcessHeap(), 0, pParam[i]);
                                pParam[i] = NULL; 
                        }
                }

                fnStorePktFields();

        }
        catch (char* errMsg) {
                logError(errMsg);
                WSACleanup();
                return false;
        }

        return true;
}

void WINAPI fnRecvPkt( LPVOID lpParam ) 
{
        pRecvPktParam pParam = (pRecvPktParam) lpParam;

        try {
                while ( pParam->pNode->nRecvSize == 0 ){
                        pParam->pNode->nRecvSize = recv(pParam->pNode->connectSocket, (char*)pParam->pNode->chRecvPkt, MAX, 0);
                        if (pParam->pNode->nRecvSize == SOCKET_ERROR) throw "fnRecvPkt: recv() fail";
                }
        }
        catch (char* errMsg) {
                logError(errMsg);
                return;
        }

        return;
}

//TODO
void fnStorePktFields() {

        //match recv pkt to templates from training mode
        /*fnMatchTemplate();*/

        //from template, determine whether cookies, etc, fields are in this pkt
        //if yes, store to node (find correct node by node->dstport)

        return;
}