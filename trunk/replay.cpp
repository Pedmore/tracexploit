
#include "TraceXploit.h"

struct rNode *rHead = (struct rNode*) NULL;
struct rNode *rEnd  = (struct rNode*) NULL;

extern char PCAPIPSRC[20];
extern char PCAPIPDST[20];
extern unsigned int PORTDST;
extern unsigned int nNodeCount;

bool fnReplay (const unsigned char* chPkt, unsigned int nPktSize, char* pOriginTargetIP, char* pReplayTargetIP) 
{
	int i;
	struct rNode* pCurr = (struct rNode*) NULL;
	
	try {
		//check whether this pkt is c-s or s-c (replay only c-s pkts in .pcap) -> pOriginTargetIP should be PCAPIPDST
		if (strcmp(pOriginTargetIP, (const char*)PCAPIPDST) != 0) return false;

		//check whether state of this pkt has already been created in linked list
		if (!fnCheckState()) {

			//establish connection for 1st time to this dst port -> store state in node
			WSADATA wsaData;
			SOCKET connectSocket;
			struct sockaddr_in serverAddr;

			WSAStartup(MAKEWORD(2,2), &wsaData);		//don't catch error as might have been initialized previously
			connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
			if(connectSocket == INVALID_SOCKET) throw "fnReplay: create TCP socket() fail";

			serverAddr.sin_family = AF_INET;
			serverAddr.sin_addr.s_addr = inet_addr(pReplayTargetIP ); 
			serverAddr.sin_port = htons(PORTDST);		
			memset(&(serverAddr.sin_zero), '\0', 8);	
	
			if (connect(connectSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)	{
				throw "fnReplay: connect() to server fail";
			}
			else {
				if (!rAddNode(connectSocket, serverAddr, pReplayTargetIP))  	throw "fnReplay: replayAddNode() new port connection fail";
			}
		}

		//replay this pkt by finding relevant node for correct socket
		pCurr = rHead;
		unsigned char* pSendPkt = (unsigned char*) calloc (nPktSize, sizeof(char));;

		while (pCurr != NULL) {
			if (pCurr->nPortDst == PORTDST) {
				//TODO: parse for fields such as cookies, dst ip string, and replace
				//      rem to change pSendPkt size if needed
				//now, only parse for dst ip string, and replace with targetIP
				fnChangePktFields (chPkt, pSendPkt, nPktSize, pReplayTargetIP);

				if (send(pCurr->connectSocket, (char*)pSendPkt, (int)_msize(pSendPkt), 0)==SOCKET_ERROR) throw "fnReplay: send() fail";
				break;
			}
			pCurr = pCurr->next;
		}
		if (pCurr == NULL) throw "fnReplay: Socket not found in linked list to send pkt";


		//recv target response
		HANDLE hThread[5] = {'\0'};
		DWORD dwThreadID[5] = {'\0'};
		pRecvPktParam pParam[5] = {'\0'};

		pCurr = rHead;
		for (i=0; pCurr != NULL; i++) {
			pParam[i] = (pRecvPktParam) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(recvPktParam));
			pParam[i]->pNode = pCurr;
			hThread[i] = CreateThread( NULL, 0,	(LPTHREAD_START_ROUTINE)fnRecvPkt, pParam[i], 0, &dwThreadID[i]);

			pCurr = pCurr->next;
		}

		WaitForMultipleObjects(i, hThread, false, 5000);


		//TODO: prog does not handle situations where 1 port finished receiving while another still receiving
		// Close thread handles and free memory
	    for(i=0; i<5; i++)
		{
			if (hThread[i]!=NULL)	CloseHandle(hThread[i]);
			if(pParam[i] != NULL)	{
				HeapFree(GetProcessHeap(), 0, pParam[i]);
				pParam[i] = NULL; 
			}
		}

		fnStorePktFields();

	}
	catch (char* errMsg) {
		logError(errMsg);
		WSACleanup();
		return false;
	}

	return true;
}

void WINAPI fnRecvPkt( LPVOID lpParam ) 
{
	pRecvPktParam pParam = (pRecvPktParam) lpParam;

	try {
		while ( pParam->pNode->nRecvSize == 0 ){
			pParam->pNode->nRecvSize = recv(pParam->pNode->connectSocket, (char*)pParam->pNode->chRecvPkt, MAX, 0);
			if (pParam->pNode->nRecvSize == SOCKET_ERROR) throw "fnRecvPkt: recv() fail";
		}
	}
	catch (char* errMsg) {
		logError(errMsg);
		return;
	}

	return;
}

//TODO
void fnStorePktFields() {

	//match recv pkt to templates from training mode
	/*fnMatchTemplate();*/

	//from template, determine whether cookies, etc, fields are in this pkt
	//if yes, store to node (find correct node by node->dstport)

	return;
}




void fnChangePktFields (const unsigned char* chPkt, unsigned char* pSendPkt, unsigned int nPktSize,  char* pReplayTargetIP) {

	unsigned int i;

	//copy replay pkt to send pkt
	memcpy_s(pSendPkt, nPktSize,  chPkt, nPktSize);

	//NOTE: length of new_targetIP_in_replay MUST EQUAL length of targetIP_in_pcap
	//TODO: make this more flexible!!!
	//simple parsing to change targetIP_in_pcap to new_targetIP_in_replay
	if (nPktSize > strlen((const char*)PCAPIPDST)) {
		for (i = 0; i < nPktSize - strlen((const char*)PCAPIPDST); i++) {
			if (memcmp(chPkt+i, PCAPIPDST, strlen((const char*)PCAPIPDST)) == 0) {
				memcpy_s(pSendPkt+i, nPktSize,  pReplayTargetIP, strlen(pReplayTargetIP));
			}
		}
	}

	return;
}

bool fnCheckState() {

	struct rNode* pCurr = rHead;
	
	while (pCurr != NULL) {
		if (pCurr->nPortDst == PORTDST) return true;

		pCurr = pCurr->next;
	}

	return false;
}




//------------------------------ linked list ------------------------------

bool rAddNode(SOCKET connectSocket, struct sockaddr_in serverAddr, char* pReplayTargetIP)
{
	struct rNode* pTokenNode;

	//replay linked list ~ queue, with max port connection storage of 5
	if (nNodeCount==5) 	 rDeletenode(rHead);

	//add this new connection to back of linked list
	pTokenNode = (struct rNode *) calloc( 1, sizeof(struct rNode ) );

	if( pTokenNode == NULL ) 							//error allocating node
		return false;						
	else {												//ok allocating node
		pTokenNode->connectSocket = connectSocket;
		memcpy_s (&(pTokenNode->serverAddr), sizeof(sockaddr_in), &serverAddr, sizeof(sockaddr_in));
		memcpy_s(pTokenNode->chIPDst, 20, pReplayTargetIP, 20);
		pTokenNode->nPortDst = PORTDST;
		pTokenNode->pCookie = NULL;
		memset(pTokenNode->chRecvPkt, 0, MAX);
		pTokenNode->nRecvSize = 0;
		pTokenNode->next = NULL;
	}

	nNodeCount++;
	rAdd(pTokenNode);

	return true;                       
}

void rAdd( struct rNode* pNewNode )
{

	if( rHead == NULL ) { 							//point head to 1st node in list
		rHead = pNewNode;        
		rEnd = pNewNode;
	}
	//pNewNode->next	= (struct rNode*) NULL; 
	rEnd->next	= pNewNode;   						//point last node to new node
	rEnd		= pNewNode;     					// point end to new node
	rEnd->next = (struct rNode*) NULL; 
}


void rDeletenode( struct rNode* pTargetToken )
{
   struct rNode *temp, *prev;
   temp = pTargetToken;  							//node to be deleted
   prev = rHead;  

   if( temp == prev ) {       						//adjustments if deleting 1st node
       rHead = rHead->next;                 
       if( rEnd == temp )                  
          rEnd = rEnd->next;                

	   shutdown(temp->connectSocket, SD_BOTH);
	   closesocket(temp->connectSocket);
	   if (temp->pCookie!=NULL) free (temp->pCookie);
       free( temp );								// free node
   }
   else {											//not deleting 1st node
       while( prev->next != temp ) {				//move prev to 2nd last node
           prev = prev->next;              
       }
       prev->next = temp->next;						// adjust end
       if( rEnd == temp )                  
           rEnd = prev;                    

	   shutdown(temp->connectSocket, SD_BOTH);
	   closesocket(temp->connectSocket);
	   if (temp->pCookie!=NULL) free (temp->pCookie);
       free( temp );								// free node
	   temp = NULL;
   }

   nNodeCount--;
   return;
}

void rDeletelist( struct rNode *ptr )
{
   struct rNode *temp;

   if( rHead == NULL ) return;  					//dont delete empty list

   if( ptr == rHead ) {  							// reset head and end if deleting whole list
       rHead = NULL;        
       rEnd = NULL;         
   }
   else {
       temp = rHead;        						//find node to start deleting if not deleting whole list
       while( temp->next != ptr )        
           temp = temp->next;
       rEnd = temp;                      
   }

   while( ptr != NULL ) {  							//delete and free nodes while there are
      temp = ptr->next;    
	  shutdown(ptr->connectSocket, SD_BOTH);
	  closesocket(ptr->connectSocket);
	  if (ptr->pCookie!=NULL) free (temp->pCookie);
      free( ptr );        
      ptr = temp;         
   }

	rHead = (struct rNode *) NULL;
	rEnd  = (struct rNode *) NULL;
	nNodeCount = 0;

	return;
}