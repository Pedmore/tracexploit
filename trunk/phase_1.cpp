
#include "TraceXploit.h"

struct tNode *tHead = (struct tNode*) NULL;
struct tNode *tEnd  = (struct tNode*) NULL;

extern char PCAPIPSRC[20];
extern char PCAPIPDST[20];
extern unsigned int nNodeCount;

bool fnTokenize(const unsigned char* chPkt, unsigned int nPktSize, char* pOriginIP) {

	unsigned int i; 

	unsigned char* pTxt = (unsigned char*) calloc (0, sizeof(unsigned char));
	unsigned char* pBin = (unsigned char*) calloc (1, sizeof(unsigned char));

	bool bTxt = false;
	bool bRet = false;

	try {
		//parse for direction of packet
		if (_strcmpi(PCAPIPDST, pOriginIP) == 0) {
			if (!tAddNode("c-s", pBin, false, false, false)) 	throw "fnTokenize: tAddNode() c-s fail";
		}
		else if (_strcmpi(PCAPIPSRC, pOriginIP) == 0) {
			if (!tAddNode("s-c", pBin, false, false, false)) 	throw "fnTokenize: tAddNode() s-c fail";
		}
		else throw "fnTokenize: OriginIP not found";


		//TODO: also parse for UNICODE text
		//parse for bin vs txt token
		for (i = 0; i < nPktSize-2; i++){

			//consecutive 3 printable char
			if ((chPkt[i]>=0x20 && chPkt[i]<=0x79) && (chPkt[i+1]>=0x20 && chPkt[i+1]<=0x79) && (chPkt[i+2]>=0x20 && chPkt[i+2]<=0x79)){
				pTxt = (unsigned char*) realloc (pTxt, _msize(pTxt) + (1 * sizeof(char)));
				if (pTxt == NULL )	throw "fnTokenize: realloc can't allocate memory";

				bTxt = true;
				pTxt[_msize(pTxt)-1] = chPkt[i];
			}
			else {
				//copy remaining 2 printable char of text sequence and tokenize
				if (bTxt == true) {
					pTxt = (unsigned char*) realloc (pTxt, _msize(pTxt) + (2 * sizeof(char)));
					if (pTxt == NULL )	throw "fnTokenize: realloc can't allocate memory";

					pTxt[_msize(pTxt)-2] = chPkt[i];
					i++;
					pTxt[_msize(pTxt)-1] = chPkt[i];		
					
					if (!fnTokenizeTxt(pTxt)) throw "fnTokenize: fnTokenizeTxt() fail";

					pTxt = (unsigned char*) calloc (0, sizeof(char));
					bTxt = false;
				}
				//tokenize bin
				else {
					pBin[0] = chPkt[i];
					if (!tAddNode("bin", pBin, false, false, false)) throw "fnTokenize: tAddNode() bin fail";
				}
			}
		}

		//tokenize last 2 bytes of bin/txt
		if (bTxt == false) {
			pBin[0] = chPkt[i];
			if (!tAddNode("bin", pBin, false, false, false)) throw "fnTokenize: tAddNode() bin fail";

			pBin[0] = chPkt[i+1];
			if (!tAddNode("bin", pBin, false, false, false)) throw "fnTokenize: tAddNode() bin fail";
		}
		else {
			pTxt = (unsigned char*) realloc (pTxt, _msize(pTxt) + (2 * sizeof(char)));
			if (pTxt == NULL )	throw "fnTokenize: realloc can't allocate memory";

			pTxt[_msize(pTxt)-2] = chPkt[i];
			pTxt[_msize(pTxt)-1] = chPkt[i+1];
				
			if (!fnTokenizeTxt(pTxt)) throw "fnTokenize: fnTokenizeTxt() fail";
		}

		//parse for null-terminated strings in linked list
		fnAdjustForNullTextToken();
	}
	catch (char* errMsg) {
		logError(errMsg);
		if(pBin!=NULL)
		{
			free(pBin); 
			pBin=NULL;
		}
		if(pTxt!=NULL)
		{
			free(pTxt); 
			pTxt=NULL;
		}
		return false;
	}

	if(pBin!=NULL)
	{
		free(pBin); 
		pBin=NULL;
	}
	if(pTxt!=NULL)
	{
		free(pTxt); 
		pTxt=NULL;
	}
	return true;
}

//meaning of txt in fnTokenizeTxt != meaning of txt in fnTokenize()
bool fnTokenizeTxt (const unsigned char* pPrintableSeq)	{
	unsigned int i;
	unsigned char* pTxt  = (unsigned char*) calloc (0, sizeof(char));	
	unsigned char* pDelim = (unsigned char*) calloc (0, sizeof(char));
	unsigned char* pStart = (unsigned char*) pPrintableSeq;
	unsigned char* pEnd = (unsigned char*) pPrintableSeq;
	bool bFlag = false;

	try {
		for (i=0; i < _msize((unsigned char*)pPrintableSeq); i++, pEnd++) {
	
			if ((*pEnd>=0x30 && *pEnd<=0x39)||(*pEnd>=0x41 && *pEnd<=0x5a)||(*pEnd>=0x61 && *pEnd<=0x7a)) {
				
				pTxt = (unsigned char*) realloc (pTxt, _msize(pTxt) + (1 * sizeof(char)));
				if (pTxt == NULL )	throw "fnTokenizeTxt: realloc can't allocate memory";

				pTxt[_msize(pTxt)-1] = *pEnd;

				//to reach here indicates has toggled delim and txt, hence link delim node
				if (_msize(pDelim) > 0) {
					if (!tAddNode("txt", pDelim, true, false, false)) throw "fnTokenizeTxt: tAddNode() pDelim fail";
					pDelim = (unsigned char*) calloc (0, sizeof(char));
				}
			}
			else{
				pDelim = (unsigned char*) realloc (pDelim, _msize(pDelim) + (1 * sizeof(char)));
				if (pDelim == NULL )	throw "fnTokenizeTxt: realloc can't allocate memory";

				pDelim[_msize(pDelim)-1] = *pEnd;

				//to reach here indicates has toggled delim and txt, hence link pTxt node
				if (_msize(pTxt) > 0) {
					if (!tAddNode("txt", pTxt, false, false, false)) throw "fnTokenizeTxt: tAddNode() pPrintableTxt fail";
					pTxt = (unsigned char*) calloc (0, sizeof(char));
				}
			}	
		}
		//tokenize last text/delim segment
		if (_msize(pTxt) > 0) {
			if (!tAddNode("txt", pTxt, false, false, false)) throw "fnTokenizeTxt: tAddNode() pPrintableTxt fail";
			pTxt = (unsigned char*) calloc (0, sizeof(char));
		}
		if (_msize(pDelim) > 0) {
			if (!tAddNode("txt", pDelim, true, false, false)) throw "fnTokenizeTxt: tAddNode() pDelim fail";
			pDelim = (unsigned char*) calloc (0, sizeof(char));
		}
	}
	catch (char* errMsg) {
		logError(errMsg);
		if(pDelim!=NULL)
		{
			free(pDelim); 
			pDelim=NULL;
		}
		if(pTxt!=NULL)
		{
			free(pTxt); 
			pTxt=NULL;
		}
		return false;
	}

	if(pDelim!=NULL)
	{
		free(pDelim); 
		pDelim=NULL;
	}
	if(pTxt!=NULL)
	{
		free(pTxt); 
		pTxt=NULL;
	}
	return true;
}

//want to consider NULL as part of text token, not binary token
void fnAdjustForNullTextToken() {
	struct tNode* pCurr = tHead;
	struct tNode* pNext = pCurr->next;

	while (pNext != NULL) {
		if ((_strcmpi(pCurr->chTokenType, "txt")==0) && (_strcmpi(pNext->chTokenType, "bin")==0)) {
			if (*(pNext->pTokenValue) == 0x00) {
				pCurr->bNullTerminated = true;
				
				//append NULl to pCurr->pTokenValue
				pCurr->pTokenValue = (unsigned char*) realloc (pCurr->pTokenValue, _msize(pCurr->pTokenValue) + (1 * sizeof(char)));
				*(pCurr->pTokenValue+_msize(pCurr->pTokenValue)-1)=NULL;
				tDeletenode(pNext);
			}
		}
		pCurr = pCurr->next;
		pNext = pCurr->next;
	}
	return;
}


//----------------------------------------------------------------------------


bool fnInitCluster (const unsigned char* chPkt, unsigned int nPktSize) {
	unsigned int i, offset;
	char* pHashOutput = (char*) calloc (100, sizeof(char));
	struct tNode* pCurr = tHead;
	unsigned char* pAllTokens = (unsigned char*) calloc (nNodeCount*3, sizeof(char));
	if (pAllTokens == NULL ) return false;

	//concatenate token types of this packet
	for (i=0; pCurr != NULL; i++ ) {
		offset = i*3;
		memcpy_s(pAllTokens+offset, nNodeCount*3, pCurr->chTokenType, 3);
		pCurr = pCurr->next;
	}

	//get MD5 hash
	if (!fnMD5(pAllTokens, pHashOutput)) return false;

	//store tokens to file
	if (!fnStoreTokens(chPkt, nPktSize, pHashOutput)) return false;


	if(pHashOutput!=NULL)
	{
		free(pHashOutput); 
		pHashOutput=NULL;
	}
	if(pAllTokens!=NULL)
	{
		free(pAllTokens); 
		pAllTokens=NULL;
	}


	return true;
}

//this function calculates the MD5
bool fnMD5 (unsigned char* pAllTokens, char* pHashOutput) {

	unsigned int i;
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    DWORD dwRead = (DWORD) _msize(pAllTokens);
	BYTE byHash[16] = {'\0'};		//MD5 output length = 16bytes
    DWORD dwHash = 16;
	char chDigitMap[] = "0123456789abcdef";

	try {
		// Get handle to the crypto provider
		if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) throw "fnMD5: CryptAcquireContext fail";

		//Initiates hashing of input stream
		if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash)) throw "fnMD5: CryptCreateHash fail";

		//Adds data to MD5 hash object
		if (!CryptHashData(hHash, pAllTokens, dwRead, 0))	throw "fnMD5: CryptHashData fail";

		//Retrieves output of MD5 hash object
		if (!CryptGetHashParam(hHash, HP_HASHVAL, byHash, &dwHash, 0))	throw "fnMD5: CryptGetHashParam fail";

		//Convert byte[] to string value: [2A 1F 2C] -> "2A1F2C"
		for (i = 0; i < dwHash; i++) {
			sprintf_s(pHashOutput+strlen(pHashOutput), 32, "%c%c", chDigitMap[byHash[i] >> 4], chDigitMap[byHash[i] & 0xf]);
		}
	}
	catch (char* errMsg) {
		logError(errMsg);
		CryptDestroyHash(hHash);
		CryptReleaseContext(hProv, 0);
		return false;
	}

    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    return true; 
}


bool fnStoreTokens (const unsigned char* chPkt, int nPktSize, const char* pHashOutput) {

	unsigned int i;
	FILE* fp = NULL;
	errno_t err;
	struct tNode* pCurr = tHead;
	char chDigitMap[] = "0123456789abcdef";
	char chFilename[MAX_PATH] = {'\0'};
	sprintf_s(chFilename, MAX_PATH, "C:\\Documents and Settings\\Administrator\\Desktop\\gsoc 2010\\TraceExploit\\TraceXploit_poc\\Debug\\%s\\%s.phase1", FOLDER, pHashOutput);

	try {
		err = fopen_s(&fp, chFilename, "a+t");
		if (err!=0) 
			throw "fnStoreTokens: fopen_s() fail";

		//assume that "<->" is a special marking for TraceXploit/Discoverer storage
		fprintf_s(fp, "---------------------------------------------------\n");
		fprintf_s(fp, "%d\n", nPktSize);

		while (pCurr != NULL) {
			fprintf_s(fp, "<->%s<->", pCurr->chTokenType);

			for (i=0; i<_msize(pCurr->pTokenValue); i++) {
				fprintf_s(fp, "%c%c", chDigitMap[*((pCurr->pTokenValue)+i) >> 4], chDigitMap[*((pCurr->pTokenValue)+i) & 0xf]);
			}
			fprintf_s(fp, "<->%c%c", chDigitMap[pCurr->bDelim >> 4], chDigitMap[pCurr->bDelim && 0xf]);
			fprintf_s(fp, "<->%c%c", chDigitMap[pCurr->bNullTerminated >> 4], chDigitMap[pCurr->bNullTerminated && 0xf]);
			fprintf_s(fp, "<->%c%c\n", chDigitMap[pCurr->bUnicode >> 4], chDigitMap[pCurr->bUnicode && 0xf]);

			pCurr = pCurr->next;
		}

		//delete linked list
		tDeletelist( tHead );
	}
	catch (char* errMsg) {
		logError(errMsg);

		if(fp != NULL)
		{
			fclose(fp);
			fp = NULL;
		}

		return false;
	}
	
	if(fp != NULL)
	{
		fclose(fp);
		fp = NULL;
	}

	return true;
}


//------------------------------ linked list ------------------------------

bool tAddNode(const char* pType, const unsigned char* pValue, bool delim, bool nullTerminated, bool unicode)
{
	struct tNode* pTokenNode;

	pTokenNode = (struct tNode *) calloc( 1, sizeof(struct tNode ) );

	if( pTokenNode == NULL )				//error allocating node
		return false;		
	else {                                  //ok allocating node
		memset(pTokenNode->chTokenType, NULL, 3);
		pTokenNode->pTokenValue = NULL;

		memcpy_s (pTokenNode->chTokenType, _countof(pTokenNode->chTokenType), pType, strlen((char*)pType));

		pTokenNode->pTokenValue = (unsigned char*) calloc (_msize((unsigned char*)pValue), sizeof(char));
		if (pTokenNode->pTokenValue == NULL) 
			return false;
		
		memcpy_s (pTokenNode->pTokenValue, _msize(pTokenNode->pTokenValue), pValue, _msize((char*)pValue));

		pTokenNode->bDelim = delim;
		pTokenNode->bNullTerminated = nullTerminated;
		pTokenNode->bUnicode = unicode;
		pTokenNode->next = NULL;
	}

	nNodeCount++;
	tAdd(pTokenNode);

	return true;                 
}

void tAdd( struct tNode* pNewNode )
{
	if( tHead == NULL ) {						//point head to 1st node in list
		tHead = pNewNode;   
		tEnd = pNewNode;
	}
	//pNewNode->next	= (struct tNode*) NULL; 
	tEnd->next	= pNewNode;						//point last node to new node
	tEnd		= pNewNode;						// point end to new node
	tEnd->next	= (struct tNode*) NULL;
}


void tDeletenode( struct tNode* pTargetToken )
{
   struct tNode *temp, *prev;
   temp = pTargetToken;							//node to be deleted
   prev = tHead; 

   if( temp == prev ) {							//adjustments if deleting 1st node
       tHead = tHead->next;                
       if( tEnd == temp )                  
          tEnd = tEnd->next;               

	   if (temp->pTokenValue!=NULL) free (temp->pTokenValue);
	   free( temp );							// free node
   }
   else {										//not deleting 1st node
       while( prev->next != temp ) {			//move prev to 2nd last node
           prev = prev->next;              
       }
       prev->next = temp->next;					// adjust end
       if( tEnd == temp )                 
           tEnd = prev;                   

	   if (temp->pTokenValue!=NULL) free (temp->pTokenValue);
       free( temp );							// free node
	   temp = NULL;
   }

   nNodeCount--;
   return;
}


void tDeletelist( struct tNode *ptr )
{
   struct tNode *temp;

   if( tHead == NULL ) return;					//dont delete empty list

   if( ptr == tHead ) {							// reset head and end if deleting whole list
       tHead = (struct tNode*) NULL;
       tEnd = (struct tNode*) NULL;	
   }
   else {
       temp = tHead;							//find node to start deleting if not deleting whole list
       while( temp->next != ptr )  
           temp = temp->next;
       tEnd = temp;                
   }

   while( ptr != NULL ) {						//delete and free nodes while there are
      temp = ptr->next;  
      free( ptr );       
      ptr = temp;        
   }

	tHead = (struct tNode *) NULL;
	tEnd  = (struct tNode *) NULL;
	nNodeCount = 0;

	return;
}








