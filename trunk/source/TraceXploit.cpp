// TraceXploit.cpp : Defines the entry point for the console application.



#include "TraceXploit.h"

unsigned int nNodeCount = 0;

char PCAPIPSRC[20] = {'\0'};    //ip in string representation. eg: "11 55 99 bb" -> "17.85.153.187"
char PCAPIPDST[20] = {'\0'};
unsigned int PORTSRC = 0;
unsigned int PORTDST = 0;


/*------------------------- convert hex to string --------------------------------
void to_hex(char buf[], int i)
{
  if (*buf == '\0')
    return;

  to_hex(buf + 2, i + 1);
  buf[1] = strtol(buf, NULL, 16);
  *buf = '\0';
}
----------------------------------------------------------------------------*/
void usage (char* cmd)
{
                printf("Usage    : %s <Mode> <PCAP_File> <Origin_IP> <Target_IP>\n "
                           "Mode     : 1 - Training Mode ['Server': Collect packets]\n"
                       "           2 - Replay Mode ['Server': Target to replay packets]\n"      
                           "PCAP_File: Both mode need pcap file\n"      
                           "Origin_IP: IP of target when in Mode 1\n"
                           "         : IP of attacker when in Mode 2\n"
                           "Target_IP: Only for Replay Mode \n"
                           "Example 1: %s 1 training.pcap 111.111.111.111\n"
                           "Example 2: %s 2 replay.pcap 111.111.111.111 999.999.999.999\n", cmd, cmd, cmd);
                fflush(stdout);
                exit(1);
}


int main(int argc, char* argv[])
{
        unsigned char chPkt[MAX] = {'\0'};
        unsigned int nPktSize = 0;
        DWORD dwFileOffset = 24;
        DWORD dwPCapSize = 0;


//      char pPcap[MAX_PATH] = "C:\\Documents and Settings\\Administrator\\Desktop\\gsoc 2010\\TraceExploit\\office\\TraceXploit_poc\\Debug\\smb.pcap";
        int i=0;        

        if (atoi(argv[1])==1) {if (argc!=4) usage(argv[0]);}
        if (atoi(argv[1])==2) {if (argc!=5) usage(argv[0]);}

        //get file size of .pcap
        FILE* fp;
        if (fopen_s(&fp, argv[2], "rb")!=0) {printf("[-] open pcap file fail (%d)\n", GetLastError()); return 1;}
        fseek(fp, 0, SEEK_END);
        dwPCapSize = ftell(fp);
        fclose(fp);

        
        nNodeCount = 0;
        while (true) {
                printf("%d ", i);
                i++;

                nPktSize = 0;
                memset(chPkt, NULL, MAX);
                if (dwFileOffset == dwPCapSize) break;
                nPktSize = fnReadPkt(argv[2], chPkt, &dwFileOffset);
//              if (nPktSize==0) break;

                if (atoi(argv[1])==1) {
                        //Phase 1: initialize linked list for 1st packet
                        if (!fnTokenize(chPkt, nPktSize, argv[3])) continue;
                        //Phase 1: cluster to token pattern
                        if (!fnInitCluster(chPkt, nPktSize)) continue; 
        //                      -> hash "node->tokenType";
        //                      -> create file with hash as name;
        //                      -> copy all values of linked list to file;
        //                      -> copy chPkt to file (for recursive clustering);
        //                      -> special marking for start of (linkedlist + chPkt) in file;

                }
                else if (atoi(argv[1])==2) {
                        if (nPktSize > 0) {
                                if (!fnReplay(chPkt, nPktSize, argv[3], argv[4])) continue;
                        }
                }

                else usage(argv[0]);
        }
/*
NOTE to myself: 
-       text + delimiter + null-terminated byte == variable (as position might be different)

-       after learning stage, during replay, match token-patterns to find template of replay packet 
        then, from template, find varying fields
        Shortlisted so far: cookies, length field, offset fields, ip (TODO), session id (TODO)  
*/
        printf("[+]DONE !!!!----------------------------\n");



        return 0;
}

unsigned int fnReadPkt (char* pPcap, unsigned char* chPkt, DWORD* dwFileOffset) {

        int i;
        FILE* fp;
        DWORD dwSize = 0;
        DWORD dwPcapFrameSize = 0;
        unsigned int TCPHeaderSize = 0;
        unsigned char chTempArr[2] = {'\0'};
        unsigned char chHexIP[4] = {'\0'};


        try{
                if (fopen_s(&fp, pPcap, "rb")!=0) throw "fnReadPkt: fopen_s() pcap file fail";

                while (true) {

                        dwPcapFrameSize = 0;
//                      fseek(fp, 0, SEEK_END);
//                      if (*dwFileOffset == ftell(fp)) break;

                        //.pcap file header + .pcap pkt frame header
                        *dwFileOffset = *dwFileOffset + 16;
                        
                        //get size of this pkt frame
                        fseek(fp, (*dwFileOffset-4), SEEK_SET);

                        //get size of (ethernet + ip + tcp + others); convert big endian to little endian
                        for (i=0; i<4; i++) {
                                dwSize = 0;
                                dwSize = fgetc(fp);
                                dwPcapFrameSize = dwPcapFrameSize + (dwSize << i*8);
                        }

                        *dwFileOffset = *dwFileOffset + dwPcapFrameSize;


                        //TraceXploit only handle [ethernet.type=ip] packets. Ethernet header size = 14
                        fseek(fp, 14-2, SEEK_CUR);
                        fread(chTempArr, sizeof(char), 2, fp);
                        if(( chTempArr[0] !=0x08 ) || ( chTempArr[1] !=0x00 )) continue;
                        
                        //TraceXploit only handle [ip.protocol=tcp] packets. IP header size = 20
                        fseek(fp, 9, SEEK_CUR);
                        fread(chTempArr, sizeof(char), 1, fp);
                        if( chTempArr[0] !=0x06 ) continue;
                        fseek(fp, -10, SEEK_CUR);

                        //get ip.src and ip.dst. IP header size = 20
                        fseek(fp, 20-8, SEEK_CUR);
                        fread(chHexIP, sizeof(char), 4, fp);
                        sprintf_s(PCAPIPSRC, 20, "%d.%d.%d.%d", chHexIP[0], chHexIP[1], chHexIP[2], chHexIP[3]);
                        fread(chHexIP, sizeof(char), 4, fp);
                        sprintf_s(PCAPIPDST, 20, "%d.%d.%d.%d", chHexIP[0], chHexIP[1], chHexIP[2], chHexIP[3]);

                        //get port.src and port.dst. TCP header size = not fixed!!!
                        fread(chTempArr, sizeof(char), 2, fp);
                        PORTSRC = (unsigned int) (chTempArr[0] << 8) + (unsigned int) (chTempArr[1]);
                        fread(chTempArr, sizeof(char), 2, fp);
                        PORTDST = (unsigned int) (chTempArr[0] << 8) + (unsigned int) (chTempArr[1]);
                        fseek(fp, 8, SEEK_CUR);
                        fread(chTempArr, sizeof(char), 1, fp);
                        TCPHeaderSize = (unsigned int) chTempArr[0] >> 2;
                        fseek(fp, -13+TCPHeaderSize, SEEK_CUR);

                        //get actual pkt content
                        dwSize = (DWORD) fread(chPkt, sizeof(char), dwPcapFrameSize-14-20-TCPHeaderSize, fp);

                        if ((dwSize!=dwPcapFrameSize-14-20-TCPHeaderSize)&& (!feof(fp))) throw "fnReadPkt: Bytes read SHOULD equal size stated in pcap pkt header";
                        else {  break;  }
                }

        }
        catch (char* errMsg) {
                logError(errMsg);
                ExitProcess(0);
        }

        return dwSize;
}


void logError (const char* errMsg) {
        FILE* fp;
        int errCode = GetLastError();

        fopen_s(&fp, "discoverer.error", "a+t");

        if (errCode == 0)
                fprintf_s(fp, "%s\n", errMsg);
        else
                fprintf_s(fp, "%s (%d)\n", errMsg, errCode);

        fclose(fp);
        fp = NULL;
        return;
}

